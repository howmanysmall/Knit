"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[180],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,m=p["".concat(s,".").concat(h)]||p[h]||u[h]||a;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},30206:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const a={sidebar_position:9},o="Intellisense",l={unversionedId:"intellisense",id:"intellisense",title:"Intellisense",description:"Knit was created before intellisense was introduced to Roblox. Unfortunately, due to the nature of how Knit is written, Knit does not benefit much from Roblox's intellisense. While the performance and stability of Knit are top-notch, the lack of intellisense can cause unnecessary strain on developers.",source:"@site/docs/intellisense.md",sourceDirName:".",slug:"/intellisense",permalink:"/Knit/docs/intellisense",draft:!1,editUrl:"https://github.com/Sleitnick/Knit/edit/master/docs/intellisense.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"defaultSidebar",previous:{title:"Middleware",permalink:"/Knit/docs/middleware"},next:{title:"VS Code Snippets",permalink:"/Knit/docs/vscodesnippets"}},s={},c=[{value:"Custom Bootstrapper",id:"custom-bootstrapper",level:2},{value:"ModuleScripts Save the Day",id:"modulescripts-save-the-day",level:3},{value:"Shifting the Problem",id:"shifting-the-problem",level:3},{value:"Module Loader",id:"module-loader",level:3},{value:"Cyclical Dependencies",id:"cyclical-dependencies",level:3},{value:"Why Not the Default",id:"why-not-the-default",level:3},{value:"Client-accessed Services",id:"client-accessed-services",level:3},{value:"Create-a-Knit",id:"create-a-knit",level:2},{value:"Using the RbxUtil Loader Module",id:"using-the-rbxutil-loader-module",level:3},{value:"Loading Services",id:"loading-services",level:3},{value:"Starting Services",id:"starting-services",level:3},{value:"Final Loader Script",id:"final-loader-script",level:3},{value:"Example Services",id:"example-services",level:3}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"intellisense"},"Intellisense"),(0,i.kt)("p",null,"Knit was created before intellisense was introduced to Roblox. Unfortunately, due to the nature of how Knit is written, Knit does not benefit much from Roblox's intellisense. While the performance and stability of Knit are top-notch, the lack of intellisense can cause unnecessary strain on developers."),(0,i.kt)("p",null,"There are a couple ways to help resolve this issue:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create your own bootstrapper to load in Knit services and controllers."),(0,i.kt)("li",{parentName:"ol"},"Create your own Knit-like framework using plain ModuleScripts.")),(0,i.kt)("admonition",{title:"Service/Controller",type:"note"},(0,i.kt)("p",{parentName:"admonition"},'In this article, any references to "Service" or "GetService" can also be implied to also include "Controller" or "GetController". It\'s simply less wordy to avoid referencing both.')),(0,i.kt)("h2",{id:"custom-bootstrapper"},"Custom Bootstrapper"),(0,i.kt)("p",null,'The verb "bootstrapping" in programming parlance is often used to describe a process that starts everything up (coming from the old phrase, "pull yourself up by your bootstraps"). In the context of Knit, this is usually handled internally when calling functions like ',(0,i.kt)("inlineCode",{parentName:"p"},"Knit.CreateService()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Knit.Start()"),". This is ideal for a framework, as the users of the framework do not need to know the messy details of the startup procedure."),(0,i.kt)("p",null,"The consequence of Knit taking control of the bootstrapping process is that all loaded services end up in a generic table (think of a bucket of assorted items). Due to the dynamic nature of this process, there is no way for Luau's type system to understand the ",(0,i.kt)("em",{parentName:"p"},"type")," of a service simply based on the string name (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'Knit.GetService("HelloService")'),"; Luau can't statically understand that this is pointing to a specific service table)."),(0,i.kt)("p",null,"Thus, the question at hand is: ",(0,i.kt)("strong",{parentName:"p"},"How do we get Luau to understand the ",(0,i.kt)("em",{parentName:"strong"},"type")," of our service?")),(0,i.kt)("h3",{id:"modulescripts-save-the-day"},"ModuleScripts Save the Day"),(0,i.kt)("p",null,"An important factor about Knit services is that they are just Lua tables with some extra items stuffed inside. This is why services are usually designed like any other module, with the exception that ",(0,i.kt)("inlineCode",{parentName:"p"},"Knit.CreateService")," is called. Then, the resultant service is returned at the end of the ModuleScript."),(0,i.kt)("p",null,"Because services are relatively statically defined, Roblox/Luau ",(0,i.kt)("em",{parentName:"p"},"can"),' understand its "type" if accessed directly. In other words, if the ModuleScript that the service lives inside is directly ',(0,i.kt)("inlineCode",{parentName:"p"},"require"),"'d, then intellisense would magically become available."),(0,i.kt)("p",null,"Thus, the fix is to simply require the services directly from their corresponding ModuleScripts, side-stepping Knit's ",(0,i.kt)("inlineCode",{parentName:"p"},"GetService")," calls entirely."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Old way:\nlocal MyService = Knit.GetService("MyService")\n\n-- New way:\nlocal MyService = require(somewhere.MyService)\n')),(0,i.kt)("h3",{id:"shifting-the-problem"},"Shifting the Problem"),(0,i.kt)("p",null,"The problem, however, is that the call to ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateService")," messes it all up. Our day is ruined. Because ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateService")," is called ",(0,i.kt)("em",{parentName:"p"},"within"),' the ModuleScript, this messes up the "type" of the service. Thankfully, this is easy to fix. We simply need to remove our call to ',(0,i.kt)("inlineCode",{parentName:"p"},"CreateService")," and instead call it within our custom bootstrap loader. We'll get to that in the next section."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- Old way:\nlocal SomeService = Knit.CreateService {\n    Name = "SomeService",\n}\nreturn SomeService\n\n-- New way; only getting rid of the Knit.CreateService call:\nlocal SomeService = {\n    Name = "SomeService",\n}\nreturn SomeService\n')),(0,i.kt)("p",null,"Now, when our service is required, Luau will properly infer the type of the service, which will provide proper intellisense. However, we are no longer calling ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateService"),", which means our service is never registered within Knit, thus ",(0,i.kt)("inlineCode",{parentName:"p"},"KnitStart")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"KnitInit")," never run. Oops. Let's fix this by writing our own service module loader."),(0,i.kt)("h3",{id:"module-loader"},"Module Loader"),(0,i.kt)("p",null,"Since we are no longer calling ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateService")," from the ModuleScript itself, our call to ",(0,i.kt)("inlineCode",{parentName:"p"},"AddServices")," will no longer work as expected. Thus, we need to write our own version of ",(0,i.kt)("inlineCode",{parentName:"p"},"AddServices")," that also calls ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateService")," on behalf of the module."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local function AddServicesCustom(parent: Instance)\n    -- For deep scan, switch GetChildren() to GetDescendants()\n    for _, v in parent:GetChildren() do\n        -- Only match on instances that are ModuleScripts and names that end with "Service":\n        if v:IsA("ModuleScript") and v.Name:match("Service$") then\n            local service = require(v) -- Load the service module\n            Knit.CreateService(service) -- Add the service into Knit\n        end\n    end\nend\n\n--Knit.AddServices(parent) (NO LONGER WILL WORK AS EXPECTED)\nAddServicesCustom(parent)\n\nKnit.Start()\n')),(0,i.kt)("admonition",{title:"Loader Module",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("a",{parentName:"p",href:"https://sleitnick.github.io/RbxUtil/api/Loader/"},"Loader")," module can be used if you do not want to write your own loader function."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local services = Loader.LoadChildren(parent, Loader.MatchesName("Service$"))\nfor _, service in services do\n    Knit.CreateService(service)\nend\n\nKnit.Start()\n'))),(0,i.kt)("h3",{id:"cyclical-dependencies"},"Cyclical Dependencies"),(0,i.kt)("p",null,"When requiring modules directly, it is possible to run into cyclical dependency errors. In short, Roblox will not allow ",(0,i.kt)("inlineCode",{parentName:"p"},"Module A")," to require ",(0,i.kt)("inlineCode",{parentName:"p"},"Module B"),", which also then requires ",(0,i.kt)("inlineCode",{parentName:"p"},"Module A"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", we have a cyclical dependency. This can happen in longer chains too (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),"->",(0,i.kt)("inlineCode",{parentName:"p"},"B"),"->",(0,i.kt)("inlineCode",{parentName:"p"},"C"),"->",(0,i.kt)("inlineCode",{parentName:"p"},"A"),")."),(0,i.kt)("p",null,"A side-effect of Knit's traditional startup procedure is that cyclical dependencies work fine. They work because modules are first loaded into memory before they grab any references to each other. Knit essentially acts as a bridge. However, ",(0,i.kt)("strong",{parentName:"p"},"this is an unintentional side-effect of Knit"),". Cyclical dependencies are a sign of poor architectural design."),(0,i.kt)("p",null,"Knit does not seek to allow cyclical dependencies. Knit will not make any effort to allow them to exist. Their allowance is a byproduct of Knit's design. If you are running into cyclical dependency problems after switching to directly requiring services (i.e. using ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Knit.GetService"),"), this is ",(0,i.kt)("em",{parentName:"p"},"not")," an issue of Knit, but rather a code structure issue on your end."),(0,i.kt)("h3",{id:"why-not-the-default"},"Why Not the Default"),(0,i.kt)("p",null,"A fair question to ask is: Why is this not the preferred setup for Knit?"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Knit's various assertions are being side-stepped to allow intellisense to work."),(0,i.kt)("li",{parentName:"ol"},"A lot of extra custom code has to be written."),(0,i.kt)("li",{parentName:"ol"},"If you are willing to go to this length, then perhaps a custom-built framework would work better.")),(0,i.kt)("h3",{id:"client-accessed-services"},"Client-accessed Services"),(0,i.kt)("p",null,"Services accessed from the client must still go through ",(0,i.kt)("inlineCode",{parentName:"p"},"Knit.GetService"),", thus cannot benefit from this structural change. A secondary module could be used as the client-facing service module, but that would be a lot more work to maintain and handle. "),(0,i.kt)("h2",{id:"create-a-knit"},"Create-a-Knit"),(0,i.kt)("p",null,"Creating your own framework like Knit is quite easy. In this short section, we will set up a simple module loader that works similar to Knit's startup procedure. However, it will lack networking capabilities. There are plenty of third-party networking libraries that can be used. Choosing which networking library to use is out of scope for this section."),(0,i.kt)("h3",{id:"using-the-rbxutil-loader-module"},"Using the RbxUtil Loader Module"),(0,i.kt)("p",null,"To help speed up this whole process, the ",(0,i.kt)("a",{parentName:"p",href:"https://sleitnick.github.io/RbxUtil/api/Loader"},"Loader")," module will be utilized. This will help us quickly load our modules and kick off any sort of startup method per module."),(0,i.kt)("p",null,"In keeping with the Service/Controller naming scheme, we will use the same names for our custom framework."),(0,i.kt)("h3",{id:"loading-services"},"Loading Services"),(0,i.kt)("p",null,"To load in our modules, we can call ",(0,i.kt)("inlineCode",{parentName:"p"},"Loader.LoadChildren")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Loader.LoadDescendants"),". This will go through and ",(0,i.kt)("inlineCode",{parentName:"p"},"require")," all found ModuleScripts, returning them in a named dictionary table, where each key represents the name of the ModuleScript, and each value is the loaded value from the ModuleScript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"local modules = Loader.LoadDescendants(ServerScriptService)\n")),(0,i.kt)("p",null,"However, this isn't very useful, as we probably have a lot of non-service ModuleScripts in our codebase. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Loader")," module lets us filter which modules to use by passing in a predicate function. A helper ",(0,i.kt)("inlineCode",{parentName:"p"},"MatchesName"),' function generator can also be used to simply filter based on the name, which is what we will do. Let\'s load all ModuleScripts that end with the word "Service":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName("Service$"))\n')),(0,i.kt)("p",null,"Great, so now we have a key/value table of loaded services! To mirror a bit of Knit, let's call the ",(0,i.kt)("inlineCode",{parentName:"p"},"OnStart")," method of each service."),(0,i.kt)("h3",{id:"starting-services"},"Starting Services"),(0,i.kt)("p",null,"It's often useful to have a startup method that gets automatically called once all of our modules are loaded. This could be done by looping through each module and calling a method if it's found:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'for _, service in services do\n    if typeof(service.OnStart) == "function" then\n        task.spawn(function()\n            service:OnStart()\n        end)\n    end\nend\n')),(0,i.kt)("p",null,"That's a bit much. Thankfully, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Loader")," module also includes a ",(0,i.kt)("inlineCode",{parentName:"p"},"SpawnAll")," function. This special function also calls ",(0,i.kt)("inlineCode",{parentName:"p"},"debug.setmemorycategory")," so that we can properly profile the memory being used per OnStart service call:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'Loader.SpawnAll(services, "OnStart")\n')),(0,i.kt)("h3",{id:"final-loader-script"},"Final Loader Script"),(0,i.kt)("p",null,"Let's merge all of the above code in one spot:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- ServerScriptService.ServerStartup\nlocal services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName("Service$"))\nLoader.SpawnAll(services, "OnStart")\n')),(0,i.kt)("p",null,"Our client-side code would look nearly identical. Just swap out the names. In this example, our controllers live in ReplicatedStorage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- StarterPlayer.StarterPlayerScripts.ClientStartup\nlocal controllers = Loader.LoadDescendants(ReplicatedStorage, Loader.MatchesName("Controller$"))\nLoader.SpawnAll(controllers, "OnStart")\n')),(0,i.kt)("h3",{id:"example-services"},"Example Services"),(0,i.kt)("p",null,"Due to this incredibly simple setup, our services are also very simple in structure; they're just tables within ModuleScripts. Nothing fancy. To use one service from another, simply require its ModuleScript. As such, intellisense comes natively baked in."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- ServerScriptService.MathService\nlocal MathService = {}\n\nfunction MathService:Add(a: number, b: number): number\n    return a + b\nend\n\nreturn MathService\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"-- ServerScriptService.CalcService\n\n-- Simply require another service to use it:\nlocal MathService = require(somewhere.MathService)\n\nlocal CalcService = {}\n\nfunction CalcService:OnStart()\n    local n1 = 10\n    local n2 = 20\n    local sum = MathService:Add(n1, n2)\n    print(`Sum of {n1} and {n2} is {sum}`)\nend\n\nreturn CalcService\n")))}u.isMDXComponent=!0}}]);