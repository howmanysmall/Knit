[{"title":"KnitServer","type":0,"sectionRef":"#","url":"/Knit/api/KnitServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ServerMiddleware? Outbound: ServerMiddleware? }   "},{"title":"ServerMiddlewareFn​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServerMiddlewareFn","content":"&lt;/&gt; type ServerMiddlewareFn = ( player: Player , args: {any} ) → ( shouldContinue: boolean, ...: any ) For more info, see ServerComm documentation.  "},{"title":"ServerMiddleware​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServerMiddleware","content":"&lt;/&gt; type ServerMiddleware = {ServerMiddlewareFn} An array of server middleware functions.  "},{"title":"ServiceDef​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServiceDef","content":"&lt;/&gt; interface ServiceDef { Name: string Client: table? Middleware: Middleware? [any]: any } Used to define a service when creating it in CreateService. The middleware tables provided will be used instead of the Knit-level middleware (if any). This allows fine-tuning each service's middleware. These can also be left out or nil to not include middleware.  "},{"title":"Service​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Service","content":"&lt;/&gt; interface Service { dName: string dClient: ServiceClient dKnitComm: Comm [any]: any }   "},{"title":"ServiceClient​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#ServiceClient","content":"&lt;/&gt; interface ServiceClient { Server: Service [any]: any }   "},{"title":"KnitOptions​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#KnitOptions","content":"&lt;/&gt; interface KnitOptions { Middleware: Middleware? SpawnRunServiceFunctions: &quot;None&quot; | &quot;Defer&quot; | &quot;Spawn&quot; | nil }  Middleware will apply to all services except ones that define their own middleware.  "},{"title":"Properties​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#properties","content":" "},{"title":"Util​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitServer.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#functions","content":" "},{"title":"CreateService​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateService","content":"&lt;/&gt; KnitServer.CreateService(serviceDefinition: ServiceDef) → Service Constructs a new service. caution Services must be created before calling Knit.Start(). -- Create a service local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } -- Expose a ToAllCaps remote function to the clients function MyService.Client:ToAllCaps(player, msg) return msg:upper() end -- Knit will call KnitStart after all services have been initialized function MyService:KnitStart() print(&quot;MyService started&quot;) end -- Knit will call KnitInit when Knit is first started function MyService:KnitInit() print(&quot;MyService initialize&quot;) end   "},{"title":"AddServices​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#AddServices","content":"&lt;/&gt; KnitServer.AddServices(parent: Instance ) → {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Knit.AddServices(somewhere.Services)   "},{"title":"AddServicesDeep​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#AddServicesDeep","content":"&lt;/&gt; KnitServer.AddServicesDeep(parent: Instance ) → {Service} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#GetService","content":"&lt;/&gt; KnitServer.GetService(serviceName: string) → Service Gets the service by name. Throws an error if the service is not found.  "},{"title":"GetServices​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#GetServices","content":"&lt;/&gt; KnitServer.GetServices() → {[string]: Service} Gets a table of all services.  "},{"title":"CreateSignal​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateSignal","content":"&lt;/&gt; KnitServer.CreateSignal() → SIGNAL_MARKER Returns a marker that will transform the current key into a RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the signal marker, which will turn into a -- RemoteSignal when Knit.Start() is called: MySignal = Knit.CreateSignal(), }, } function MyService:KnitInit() -- Connect to the signal: self.Client.MySignal:Connect(function(player, ...) end) end   "},{"title":"CreateUnreliableSignal​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateUnreliableSignal","content":"&lt;/&gt; KnitServer.CreateUnreliableSignal() → UNRELIABLE_SIGNAL_MARKER Returns a marker that will transform the current key into an unreliable RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. Unreliable Events Internally, this uses UnreliableRemoteEvents, which allows for network communication that is unreliable and unordered. This is useful for events that are not crucial for gameplay, since the delivery of the events may occur out of order or not at all. See the documentation for UnreliableRemoteEvents for more info.  "},{"title":"CreateProperty​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#CreateProperty","content":"&lt;/&gt; KnitServer.CreateProperty(initialValue: any) → PROPERTY_MARKER Returns a marker that will transform the current key into a RemoteProperty once the service is created. Should only be called within the Client table of a service. An initial value can be passed along as well. RemoteProperties are great for replicating data to all of the clients. Different data can also be set per client. See RemoteProperty documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { -- Create the property marker, which will turn into a -- RemoteProperty when Knit.Start() is called: MyProperty = Knit.CreateProperty(&quot;HelloWorld&quot;), }, } function MyService:KnitInit() -- Change the value of the property: self.Client.MyProperty:Set(&quot;HelloWorldAgain&quot;) end   "},{"title":"Start​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#Start","content":"&lt;/&gt; KnitServer.Start(options: KnitOptions?) → Promise Starts Knit. Should only be called once. Optionally, KnitOptions can be passed in order to set Knit's custom configurations. caution Be sure that all services have been created before calling Start. Services cannot be added later. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) Example of Knit started with options: Knit.Start({ Middleware = { Inbound = { function(player, args) print(&quot;Player is giving following args to server:&quot;, args) return true end }, }, }):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitServer","url":"/Knit/api/KnitServer#OnStart","content":"&lt;/&gt; KnitServer.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit services but is not the script that called Start. Knit.OnStart():andThen(function() local MyService = Knit.Services.MyService MyService:DoSomething() end):catch(warn)  "},{"title":"Controllers","type":0,"sectionRef":"#","url":"/Knit/docs/controllers","content":"","keywords":""},{"title":"Controllers Defined​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#controllers-defined","content":"Controllers are singleton provider objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. For the sake of example, we will develop a CameraController. "},{"title":"Creating Controllers​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#creating-controllers","content":"In its simplest form, a controller can be created like so: local CameraController = Knit.CreateController { Name = &quot;CameraController&quot; } return CameraController  The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = &quot;CameraController&quot;). The last line (return CameraController) assumes this code is written in a ModuleScript, which is best practice for containing controllers. "},{"title":"Adding Methods​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-methods","content":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. function CameraController:LockTo(part) -- TODO: Lock camera end function CameraController:Unlock() -- TODO: Unlock end  "},{"title":"Adding Properties​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-properties","content":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: CameraController.Distance = 20 CameraController.Locked = false  "},{"title":"Adding Basic Behavior​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#adding-basic-behavior","content":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. function CameraController:LockTo(part) local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end function CameraController:Unlock() local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom end  "},{"title":"More Behavior​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#more-behavior","content":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. local RunService = game:GetService(&quot;RunService&quot;) CameraController.RenderName = &quot;CustomCamRender&quot; CameraController.Priority = Enum.RenderPriority.Camera.Value function CameraController:LockTo(part) if (self.Locked) then return end -- Stop if already locked local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable -- Bind to RenderStep: RunService:BindToRenderStep(self.RenderName, self.Priority, function() cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end) end function CameraController:Unlock() if (not self.Locked) then return end -- Stop if already unlocked local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom -- Unbind: RunService:UnbindFromRenderStep(self.RenderName) end  "},{"title":"Events​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#events","content":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. local Signal = require(Knit.Util.Signal) CameraController.LockedChanged = Signal.new() function CameraController:LockTo(part) -- Other code... self.LockedChanged:Fire(true) end function CameraController:Unlock() -- Other code... self.LockedChanged:Fire(false) end  Other code could then listen in for that event: -- Somewhere else on the client local CameraController = Knit.GetController(&quot;CameraController&quot;) CameraController.LockedChanged:Connect(function(isLocked) print(if isLocked then &quot;Camera is now locked&quot; else &quot;Camera was unlocked&quot;) end)  "},{"title":"Server Communication​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#server-communication","content":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: function CameraController:KnitStart() local SomeService = Knit.GetService(&quot;SomeService&quot;) SomeService:DoSomething() SomeService.SomeEvent:Connect(function(...) end) SomeService.AnotherEvent:Fire(&quot;Some data&quot;) end  No client table forces server-only mode If the Client table is omitted from the service, the service will be interpreted as server-side only. This means that the client will not be able to access the service using Knit.GetService on the client if there is no Client table present. "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Controllers","url":"/Knit/docs/controllers#knitinit-and-knitstart","content":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model. These methods can be added just like any other method: function CameraController:KnitStart() print(&quot;CameraController KnitStart called&quot;) end function CameraController:KnitInit() print(&quot;CameraController KnitInit called&quot;) end  "},{"title":"KnitClient","type":0,"sectionRef":"#","url":"/Knit/api/KnitClient","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: ClientMiddleware? Outbound: ClientMiddleware? }   "},{"title":"ClientMiddlewareFn​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ClientMiddlewareFn","content":"&lt;/&gt; type ClientMiddlewareFn = (args: {any}) → ( shouldContinue: boolean, ...: any ) For more info, see ClientComm documentation.  "},{"title":"ClientMiddleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ClientMiddleware","content":"&lt;/&gt; type ClientMiddleware = {ClientMiddlewareFn} An array of client middleware functions.  "},{"title":"PerServiceMiddleware​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#PerServiceMiddleware","content":"&lt;/&gt; type PerServiceMiddleware = {[string]: Middleware}   "},{"title":"ControllerDef​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#ControllerDef","content":"&lt;/&gt; interface ControllerDef { Name: string [any]: any } Used to define a controller when creating it in CreateController.  "},{"title":"Controller​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Controller","content":"&lt;/&gt; interface Controller { Name: string [any]: any }   "},{"title":"KnitOptions​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#KnitOptions","content":"&lt;/&gt; interface KnitOptions { ServicePromises: boolean? Middleware: Middleware? PerServiceMiddleware: PerServiceMiddleware? SpawnRunServiceFunctions: &quot;None&quot; | &quot;Defer&quot; | &quot;Spawn&quot; | nil } ServicePromises defaults to true and indicates if service methods use promises. Each service will go through the defined middleware, unless the service has middleware defined in PerServiceMiddleware.  "},{"title":"Properties​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#properties","content":" "},{"title":"Player​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Player","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Player: Player  Reference to the LocalPlayer.  "},{"title":"Util​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Util: Folder  References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#functions","content":" "},{"title":"CreateController​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#CreateController","content":"&lt;/&gt; KnitClient.CreateController(controllerDefinition: ControllerDef) → Controller Creates a new controller. caution Controllers must be created before calling Knit.Start(). -- Create a controller local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() print(&quot;MyController started&quot;) end function MyController:KnitInit() print(&quot;MyController initialized&quot;) end   "},{"title":"AddControllers​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#AddControllers","content":"&lt;/&gt; KnitClient.AddControllers(parent: Instance ) → {Controller} Requires all the modules that are children of the given parent. This is an easy way to quickly load all controllers that might be in a folder. Knit.AddControllers(somewhere.Controllers)   "},{"title":"AddControllersDeep​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#AddControllersDeep","content":"&lt;/&gt; KnitClient.AddControllersDeep(parent: Instance ) → {Controller} Requires all the modules that are descendants of the given parent.  "},{"title":"GetService​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetService","content":"&lt;/&gt; KnitClient.GetService(serviceName: string) → Service "},{"title":"Types","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient##","content":""},{"title":"​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Service","content":"interface Service { [any]: any }  Returns a Service object which is a reflection of the remote objects within the Client table of the given service. Throws an error if the service is not found. If a service's Client table contains RemoteSignals and/or RemoteProperties, these values are reflected asClientRemoteSignals and ClientRemoteProperties. -- Server-side service creation: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { MySignal = Knit.CreateSignal(), MyProperty = Knit.CreateProperty(&quot;Hello&quot;), }, } function MyService:AddOne(player, number) return number + 1 end ------------------------------------------------- -- Client-side service reflection: local MyService = Knit.GetService(&quot;MyService&quot;) -- Call a method: local num = MyService:AddOne(5) --&gt; 6 -- Fire a signal to the server: MyService.MySignal:Fire(&quot;Hello&quot;) -- Listen for signals from the server: MyService.MySignal:Connect(function(message) print(message) end) -- Observe the initial value and changes to properties: MyService.MyProperty:Observe(function(value) print(value) end) caution Services are only exposed to the client if the service has remote-based content in the Client table. If not, the service will not be visible to the client. KnitClient.GetService will only work on services that expose remote-based content on their Client tables.  "},{"title":"GetController​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetController","content":"&lt;/&gt; KnitClient.GetController(controllerName: string) → Controller Gets the controller by name. Throws an error if the controller is not found.  "},{"title":"GetControllers​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#GetControllers","content":"&lt;/&gt; KnitClient.GetControllers() → {[string]: Controller} Gets a table of all controllers.  "},{"title":"Start​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#Start","content":"&lt;/&gt; KnitClient.Start(options: KnitOptions?) → Promise Starts Knit. Should only be called once per client. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) By default, service methods exposed to the client will return promises. To change this behavior, set the ServicePromises option to false: Knit.Start({ServicePromises = false}):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)   "},{"title":"OnStart​","type":1,"pageTitle":"KnitClient","url":"/Knit/api/KnitClient#OnStart","content":"&lt;/&gt; KnitClient.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit controllers but is not the script that called Start. Knit.OnStart():andThen(function() local MyController = Knit.GetController(&quot;MyController&quot;) MyController:DoSomething() end):catch(warn)  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/Knit/docs/gettingstarted","content":"","keywords":""},{"title":"Tutorial Videos​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#tutorial-videos","content":"Knit can be used via two workflows: Roblox Studio and externally with Rojo and Wally. To help explain how Knit is used through both workflows, check out the tutorial videos for each: Knit Tutorial for StudioKnit Tutorial for Rojo/Wally "},{"title":"Install​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#install","content":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library.Place Knit directly within ReplicatedStorage. Rojo/Wally workflow: Add Knit to your wally.toml dependency list (e.g. Knit = &quot;sleitnick/knit@^1.7&quot;) Require Knit like any other module grabbed from Wally Wally Not familiar with Wally? Wally is a package manager (like NPM) for the Roblox ecosystem. To get started, check out the Wally repository. "},{"title":"Basic Usage​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#basic-usage","content":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'await()' to the end to yield until the whole sequence is completed: -- Knit.Start():catch(warn):await()  That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. "},{"title":"A Simple Service​","type":1,"pageTitle":"Getting Started","url":"/Knit/docs/gettingstarted#a-simple-service","content":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Create the service: local MoneyService = Knit.CreateService { Name = &quot;MoneyService&quot;, } -- Add some methods to the service: function MoneyService:GetMoney(player) -- Do some sort of data fetch local money = someDataStore:GetAsync(&quot;money&quot;) return money end function MoneyService:GiveMoney(player, amount) -- Do some sort of data fetch local money = self:GetMoney(player) money += amount someDataStore:SetAsync(&quot;money&quot;, money) end Knit.Start():catch(warn)  note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: -- Money service on the server ... function MoneyService.Client:GetMoney(player) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self.Server:GetMoney(player) end ...  We can write client-side code to fetch money from the service: -- Client-side code local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) MoneyService:GetMoney():andThen(function(money) print(money) end) -- Don't want to use promises? When you start Knit on the client, -- set the ServicePromises option to false:  Turn Off Promises Don't want to use promises when the client calls a service method? Set the ServicePromises option to false when you start Knit on the client: Knit.Start({ServicePromises = false}):catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) local money = MoneyService:GetMoney()  Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services. "},{"title":"Examples","type":0,"sectionRef":"#","url":"/Knit/docs/examples","content":"","keywords":""},{"title":"Start All Services​","type":1,"pageTitle":"Examples","url":"/Knit/docs/examples#start-all-services","content":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script]Services [Folder] MyService [Module]AnotherService [Module]HelloService [Module] We can write our KnitRuntime script as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services: for _, v in script.Parent.Services:GetDescendants() do if v:IsA(&quot;ModuleScript&quot;) then require(v) end end Knit.Start():catch(warn)  Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services within 'Services': Knit.AddServices(script.Parent.Services) -- Load all services (the Deep version scans all descendants of the passed instance): Knit.AddServicesDeep(script.Parent.OtherServices) Knit.Start():catch(warn)  tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.  "},{"title":"Expose a Collection of Modules​","type":1,"pageTitle":"Examples","url":"/Knit/docs/examples#expose-a-collection-of-modules","content":"Like Knit.Util, we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules, we can expose this within our main runtime script: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Expose our MyModules folder: Knit.MyModules = game:GetService(&quot;ReplicatedStorage&quot;).MyModules -- Load services/controllers Knit.Start()  We can then use these modules elsewhere. For instance: local SomeModule = require(Knit.MyModules.SomeModule)  "},{"title":"Execution Model","type":0,"sectionRef":"#","url":"/Knit/docs/executionmodel","content":"","keywords":""},{"title":"Lifecycle​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#lifecycle","content":"The execution model of Knit defines the flow of operations and lifecycle of Knit. Require the Knit moduleCreate services or controllersCall Knit.Start(), which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finishAll KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves  On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load services or controllers here Knit.Start():catch(warn)  Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). caution Services and controllers cannot be created after Knit.Start() has been called. "},{"title":"Catching KnitInit Errors​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#catching-knitinit-errors","content":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: local success, err = Knit.Start():await() if not success then -- Handle error error(tostring(err)) end  Knit.Start():catch(function(err) -- Handle error warn(tostring(err)) end)  "},{"title":"Best Practices​","type":1,"pageTitle":"Execution Model","url":"/Knit/docs/executionmodel#best-practices","content":"Only one Script on the server should manage loading services and starting KnitOnly one LocalScript on the client should manage loading controllers and starting KnitSplit up services and controllers into their own modulesServices should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the clientCode within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possibleEvents and methods should never be added to a service's Client table after Knit.Start() has been calledAs shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup. "},{"title":"About","type":0,"sectionRef":"#","url":"/Knit/docs/intro","content":"","keywords":""},{"title":"Why Choose Knit?​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#why-choose-knit","content":""},{"title":"Structure​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#structure","content":"Services and controllers are the core of Knit. These objects provide a foundation for Roblox experiences. By orienting core game logic around services and controllers, developers will inherit cleaner organization across codebases and easier maintainability. Services and controllers are easy to create, and provide a built-in networking layer. "},{"title":"Networking Layer​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#networking-layer","content":"Knit automatically provides networking between the client and services. Since Knit handles the networking infrastructure, developers are not left with the burden of manually creating RemoteEvent and RemoteFunction objects throughout the hierarchy. Each service has the ability to expose specific endpoints to the client through declarative code. "},{"title":"Extensible​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#extensible","content":"Knit is built to be extensible. Developers write their own bootstrapping code to start and configure Knit, which gives developers the freedom to extend how Knit functions. "},{"title":"For Everyone​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#for-everyone","content":"From professional game studios to independent developers, Knit offers a powerful and easy-to-use foundation for Roblox experiences. Knit is available from both Wally and from the Roblox library, allowing developers to choose between a Rojo-based or Studio-based workflow. "},{"title":"Widely Used​","type":1,"pageTitle":"About","url":"/Knit/docs/intro#widely-used","content":"Knit has been battle-tested in the Roblox ecosystem, and has proven itself to be reliable in both stability and scale. Knit is also open-source and encourages developers to contribute to the growth of the framework. "},{"title":"Util","type":0,"sectionRef":"#","url":"/Knit/docs/util","content":"","keywords":""},{"title":"Knit via Wally​","type":1,"pageTitle":"Util","url":"/Knit/docs/util#knit-via-wally","content":"When installing Knit with Wally, developers should pull in utility modules via Wally as required. Knit's utility modules are significantly slimmed down in the Wally release. "},{"title":"Knit via ModuleScript​","type":1,"pageTitle":"Util","url":"/Knit/docs/util#knit-via-modulescript","content":"Knit comes with a few utility modules. If Knit is being used from the packaged ModuleScript, then the best way to access these modules is via require(Knit.Util.PACKAGE). The following modules are available: Knit.Util.CommKnit.Util.ComponentKnit.Util.EnumListKnit.Util.InputKnit.Util.OptionKnit.Util.SignalKnit.Util.StreamableKnit.Util.TableUtilKnit.Util.TimerKnit.Util.TroveKnit.Util.Promise Below is an example of the Signal class being used in a service: local Signal = require(Knit.Util.Signal) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, SomeSignal = Signal.new(), }  "},{"title":"Intellisense","type":0,"sectionRef":"#","url":"/Knit/docs/intellisense","content":"","keywords":""},{"title":"Custom Bootstrapper​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#custom-bootstrapper","content":"The verb &quot;bootstrapping&quot; in programming parlance is often used to describe a process that starts everything up (coming from the old phrase, &quot;pull yourself up by your bootstraps&quot;). In the context of Knit, this is usually handled internally when calling functions like Knit.CreateService() and Knit.Start(). This is ideal for a framework, as the users of the framework do not need to know the messy details of the startup procedure. The consequence of Knit taking control of the bootstrapping process is that all loaded services end up in a generic table (think of a bucket of assorted items). Due to the dynamic nature of this process, there is no way for Luau's type system to understand the type of a service simply based on the string name (e.g. Knit.GetService(&quot;HelloService&quot;); Luau can't statically understand that this is pointing to a specific service table). Thus, the question at hand is: How do we get Luau to understand the type of our service? "},{"title":"ModuleScripts Save the Day​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#modulescripts-save-the-day","content":"An important factor about Knit services is that they are just Lua tables with some extra items stuffed inside. This is why services are usually designed like any other module, with the exception that Knit.CreateService is called. Then, the resultant service is returned at the end of the ModuleScript. Because services are relatively statically defined, Roblox/Luau can understand its &quot;type&quot; if accessed directly. In other words, if the ModuleScript that the service lives inside is directly require'd, then intellisense would magically become available. Thus, the fix is to simply require the services directly from their corresponding ModuleScripts, side-stepping Knit's GetService calls entirely. -- Old way: local MyService = Knit.GetService(&quot;MyService&quot;) -- New way: local MyService = require(somewhere.MyService)  "},{"title":"Shifting the Problem​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#shifting-the-problem","content":"The problem, however, is that the call to CreateService messes it all up. Our day is ruined. Because CreateService is called within the ModuleScript, this messes up the &quot;type&quot; of the service. Thankfully, this is easy to fix. We simply need to remove our call to CreateService and instead call it within our custom bootstrap loader. We'll get to that in the next section. -- Old way: local SomeService = Knit.CreateService { Name = &quot;SomeService&quot;, } return SomeService -- New way; only getting rid of the Knit.CreateService call: local SomeService = { Name = &quot;SomeService&quot;, } return SomeService  Now, when our service is required, Luau will properly infer the type of the service, which will provide proper intellisense. However, we are no longer calling CreateService, which means our service is never registered within Knit, thus KnitStart and KnitInit never run. Oops. Let's fix this by writing our own service module loader. "},{"title":"Module Loader​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#module-loader","content":"Since we are no longer calling CreateService from the ModuleScript itself, our call to AddServices will no longer work as expected. Thus, we need to write our own version of AddServices that also calls CreateService on behalf of the module. local function AddServicesCustom(parent: Instance) -- For deep scan, switch GetChildren() to GetDescendants() for _, v in parent:GetChildren() do -- Only match on instances that are ModuleScripts and names that end with &quot;Service&quot;: if v:IsA(&quot;ModuleScript&quot;) and v.Name:match(&quot;Service$&quot;) then local service = require(v) -- Load the service module Knit.CreateService(service) -- Add the service into Knit end end end --Knit.AddServices(parent) (NO LONGER WILL WORK AS EXPECTED) AddServicesCustom(parent) Knit.Start()  Loader Module The Loader module can be used if you do not want to write your own loader function. local services = Loader.LoadChildren(parent, Loader.MatchesName(&quot;Service$&quot;)) for _, service in services do Knit.CreateService(service) end Knit.Start()  "},{"title":"Cyclical Dependencies​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#cyclical-dependencies","content":"When requiring modules directly, it is possible to run into cyclical dependency errors. In short, Roblox will not allow Module A to require Module B, which also then requires Module A. If A requires B, and B requires A, we have a cyclical dependency. This can happen in longer chains too (e.g. A-&gt;B-&gt;C-&gt;A). A side-effect of Knit's traditional startup procedure is that cyclical dependencies work fine. They work because modules are first loaded into memory before they grab any references to each other. Knit essentially acts as a bridge. However, this is an unintentional side-effect of Knit. Cyclical dependencies are a sign of poor architectural design. Knit does not seek to allow cyclical dependencies. Knit will not make any effort to allow them to exist. Their allowance is a byproduct of Knit's design. If you are running into cyclical dependency problems after switching to directly requiring services (i.e. using require instead of Knit.GetService), this is not an issue of Knit, but rather a code structure issue on your end. "},{"title":"Why Not the Default​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#why-not-the-default","content":"A fair question to ask is: Why is this not the preferred setup for Knit? Knit's various assertions are being side-stepped to allow intellisense to work.A lot of extra custom code has to be written.If you are willing to go to this length, then perhaps a custom-built framework would work better. "},{"title":"Client-accessed Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#client-accessed-services","content":"Services accessed from the client must still go through Knit.GetService, thus cannot benefit from this structural change. A secondary module could be used as the client-facing service module, but that would be a lot more work to maintain and handle. "},{"title":"Create-a-Knit​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#create-a-knit","content":"Creating your own framework like Knit is quite easy. In this short section, we will set up a simple module loader that works similar to Knit's startup procedure. However, it will lack networking capabilities. There are plenty of third-party networking libraries that can be used. Choosing which networking library to use is out of scope for this section. "},{"title":"Using the RbxUtil Loader Module​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#using-the-rbxutil-loader-module","content":"To help speed up this whole process, the Loader module will be utilized. This will help us quickly load our modules and kick off any sort of startup method per module. In keeping with the Service/Controller naming scheme, we will use the same names for our custom framework. "},{"title":"Loading Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#loading-services","content":"To load in our modules, we can call Loader.LoadChildren or Loader.LoadDescendants. This will go through and require all found ModuleScripts, returning them in a named dictionary table, where each key represents the name of the ModuleScript, and each value is the loaded value from the ModuleScript. local modules = Loader.LoadDescendants(ServerScriptService)  However, this isn't very useful, as we probably have a lot of non-service ModuleScripts in our codebase. The Loader module lets us filter which modules to use by passing in a predicate function. A helper MatchesName function generator can also be used to simply filter based on the name, which is what we will do. Let's load all ModuleScripts that end with the word &quot;Service&quot;: local services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName(&quot;Service$&quot;))  Great, so now we have a key/value table of loaded services! To mirror a bit of Knit, let's call the OnStart method of each service. "},{"title":"Starting Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#starting-services","content":"It's often useful to have a startup method that gets automatically called once all of our modules are loaded. This could be done by looping through each module and calling a method if it's found: for _, service in services do if typeof(service.OnStart) == &quot;function&quot; then task.spawn(function() service:OnStart() end) end end  That's a bit much. Thankfully, the Loader module also includes a SpawnAll function. This special function also calls debug.setmemorycategory so that we can properly profile the memory being used per OnStart service call: Loader.SpawnAll(services, &quot;OnStart&quot;)  "},{"title":"Final Loader Script​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#final-loader-script","content":"Let's merge all of the above code in one spot: -- ServerScriptService.ServerStartup local services = Loader.LoadDescendants(ServerScriptService, Loader.MatchesName(&quot;Service$&quot;)) Loader.SpawnAll(services, &quot;OnStart&quot;)  Our client-side code would look nearly identical. Just swap out the names. In this example, our controllers live in ReplicatedStorage: -- StarterPlayer.StarterPlayerScripts.ClientStartup local controllers = Loader.LoadDescendants(ReplicatedStorage, Loader.MatchesName(&quot;Controller$&quot;)) Loader.SpawnAll(controllers, &quot;OnStart&quot;)  "},{"title":"Example Services​","type":1,"pageTitle":"Intellisense","url":"/Knit/docs/intellisense#example-services","content":"Due to this incredibly simple setup, our services are also very simple in structure; they're just tables within ModuleScripts. Nothing fancy. To use one service from another, simply require its ModuleScript. As such, intellisense comes natively baked in. -- ServerScriptService.MathService local MathService = {} function MathService:Add(a: number, b: number): number return a + b end return MathService  -- ServerScriptService.CalcService -- Simply require another service to use it: local MathService = require(somewhere.MathService) local CalcService = {} function CalcService:OnStart() local n1 = 10 local n2 = 20 local sum = MathService:Add(n1, n2) print(`Sum of {n1} and {n2} is {sum}`) end return CalcService  "},{"title":"Middleware","type":0,"sectionRef":"#","url":"/Knit/docs/middleware","content":"","keywords":""},{"title":"Usage​","type":1,"pageTitle":"Middleware","url":"/Knit/docs/middleware#usage","content":"Middleware is added when Knit is started: Knit.Start({Middleware = {Inbound = {...}, Outbound = {...}}}) or on each service. Each &quot;middleware&quot; item in the tables is a function. On the client, this function takes an array table containing all the arguments passed along. On the server, it is nearly the same, except the first argument before the arguments table is the player. Each function should return a boolean, indicating whether or not to continue to the request/response. If false, an optional variadic list of items can be returned, which will be returned back to the caller (essentially a short-circuit, but still returning data). Client middleware function signature: (args: {any}) -&gt; (boolean, ...)Server middleware function signature: (player: Player, args: {any}) -&gt; (boolean, ...) "},{"title":"Examples​","type":1,"pageTitle":"Middleware","url":"/Knit/docs/middleware#examples","content":"Logger​ Here's an example on the client which logs all inbound data from the server: local function Logger(args: { any }) print(args) return true end Knit.Start({ Middleware = { Inbound = { Logger } } })  Here's the same thing, but on the server. As you can see, the only difference is that the player argument is added to the middleware function: local function Logger(player: Player, args: { any }) print(player, args) return true end Knit.Start({ Middleware = { Inbound = { Logger } } })  Manipulation​ A more complex example, where any inbound number to the client is multiplied by 2: local function DoubleNumbers(args) for i, v in args do if type(v) == &quot;number&quot; then args[i] *= 2 end end return true end Knit.Start({ Middleware = { Inbound = { DoubleNumbers } } })  Per-Service Example​ Middleware can also be targeted per-service, which will override the global level middleware for the given service. -- Server-side: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, Middleware = { Inbound = { Logger }, Outbound = {}, }, }  On the client, things look a little different. Middleware is still per-service, not controller, so the definitions of per-service middleware need to go within Knit.Start() on the client: -- Client-side: Knit.Start({ PerServiceMiddleware = { -- Mapped by name of the service MyService = { Inbound = { Logger }, Outbound = {}, }, }, })  Serialization​ Another example, where a simple class is serialized/deserialized on the client before/after remote network communication occurs. A similar setup could be used server-side to complete the loop: ----------------------------------------------------- -- Setup a simple class: local MyClass = {} MyClass.__index = MyClass MyClass.ClassName = &quot;MyClass&quot; function MyClass.new() return setmetatable({ SomeData = &quot;&quot;, }, MyClass) end function MyClass:Serialize() return { _CN = self.ClassName, D = self.SomeData } end function MyClass.deserialize(data) local myClass = MyClass.new() myClass.SomeData = data return myClass end ----------------------------------------------------- -- Setup middleware for class serialization/deserialization on client: local function InboundClass(args) for i, v in args do if type(v) == &quot;table&quot; and v._CN == &quot;MyClass&quot; then args[i] = MyClass.deserialize(v) end end return true end local function OutboundClass(args) for i, v in args do if type(v) == &quot;table&quot; and v.ClassName == &quot;MyClass&quot; then args[i] = v:Serialize() end end return true end Knit.Start({ Middleware = { Inbound = { InboundClass }, Outbound = { OutboundClass }, }, })  "},{"title":"VS Code Snippets","type":0,"sectionRef":"#","url":"/Knit/docs/vscodesnippets","content":"","keywords":""},{"title":"Using Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#using-snippets","content":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -&gt; Preferences -&gt; User SnippetsType in and select lua.jsonWithin the {} braces, include any or all of the snippets belowSave the fileWithin your actual source files, start typing a prefix (e.g. &quot;knit&quot;) and select the autocompleted snippet to paste it inDepending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)  "},{"title":"Knit Snippets​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-snippets","content":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. "},{"title":"Knit​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit","content":"Include a require statement for Knit. Snippet &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit)   "},{"title":"Service​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#service","content":"Reference a Roblox service. Snippet &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }  Code Result local HttpService = game:GetService(&quot;HttpService&quot;)   "},{"title":"Knit Service​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-service","content":"Reference Knit, create a service, and return the service. Snippet &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = {}, } function MyService:KnitStart() end function MyService:KnitInit() end return MyService   "},{"title":"Knit Controller​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-controller","content":"Reference Knit, create a controller, and return the controller. Snippet &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }  Code Result local Knit = require(ReplicatedStorage.Packages.Knit) local MyController = Knit.CreateController { Name = &quot;MyController&quot;, } function MyController:KnitStart() end function MyController:KnitInit() end return MyController   "},{"title":"Knit Require​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#knit-require","content":"Require a module within Knit. Snippet &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; }  Code Result local Signal = require(Knit.Util.Signal)   "},{"title":"Lua Class​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#lua-class","content":"A standard Lua class. Snippet &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }  Code Result local MyClass = {} MyClass.__index = MyClass function MyClass.new() local self = setmetatable({}, MyClass) return self end function MyClass:Destroy() end return MyClass   "},{"title":"All​","type":1,"pageTitle":"VS Code Snippets","url":"/Knit/docs/vscodesnippets#all","content":"All the above snippets together. All Snippets { &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }, &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }, &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }, &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;,&quot;, &quot;\\tClient = {},&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }, &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(ReplicatedStorage.Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }, &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; } }  "},{"title":"Services","type":0,"sectionRef":"#","url":"/Knit/docs/services","content":"","keywords":""},{"title":"Services Defined​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#services-defined","content":"Services are singleton provider objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. "},{"title":"Creating Services​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#creating-services","content":"In its simplest form, a service can be created like so: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = {} } return PointsService  Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. No client table forces server-only mode If the Client table is omitted, the service will be interpreted as server-side only. This means that the client will not be able to access this service using Knit.GetService on the client. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = &quot;PointsService&quot;). The last line (return PointsService) assumes this code is written in a ModuleScript, which is best practice for containing services. "},{"title":"Adding methods​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#adding-methods","content":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. function PointsService:AddPoints(player, amount) -- TODO: add points end function PointsService:GetPoints(player) return 0 end  "},{"title":"Adding properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#adding-properties","content":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: PointsService.PointsPerPlayer = {}  "},{"title":"Using methods and properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#using-methods-and-properties","content":"Now we can change our AddPoints() and GetPoints() methods to use this field. PointsService.PointsPerPlayer = {} function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) -- Current amount of points points += amount -- Add points self.PointsPerPlayer[player] = points -- Store points end function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return if points ~= nil then points else 0 -- Return 0 if no points found for player end  "},{"title":"Using events​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#using-events","content":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: -- Load the Signal module and create PointsChanged signal: local Signal = require(Knit.Util.Signal) PointsService.PointsChanged = Signal.new() -- Modify AddPoints: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points -- Fire event signal, as long as we actually changed the points: if amount ~= 0 then self.PointsChanged:Fire(player, points) end end  Another service could then listen for the changes on that event: function SomeOtherService:KnitStart() local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(player, points) print(&quot;Points changed for &quot; .. player.Name .. &quot;:&quot;, points) end) end  "},{"title":"KnitInit and KnitStart​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#knitinit-and-knitstart","content":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. "},{"title":"Cleaning Up Unused Memory​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#cleaning-up-unused-memory","content":"Alright, back to our PointsService! We have a problem... We have created a memory leak! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: function PointsService:KnitInit() game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) -- Clear out the data for the player when the player leaves: self.PointsPerPlayer[player] = nil end) end  While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. "},{"title":"Client Communication​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#client-communication","content":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. "},{"title":"Methods​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#methods","content":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: function PointsService.Client:GetPoints(player) -- We can just call our other method from here: return self.Server:GetPoints(player) end  This creates a client-exposed method called GetPoints. Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService:GetPoints():andThen(function(points) print(&quot;Points for myself:&quot;, points) end)  "},{"title":"Events (Server-to-Client)​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#events-server-to-client","content":"We can use remote signals to fire events from the server to the clients. Continuing with the previous PointsService example, let's create a signal that fires when a client's points change. We can use Knit.CreateSignal() to indicate we want a signal created for the service. local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), -- Create the signal }, }  Remote Signal See the RemoteSignal documentation for more info on how to use the RemoteSignal object. Under the hood, Knit is using the Comm module, which is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) -- Fire the client signal: self.Client.PointsChanged:Fire(player, points) end end  And from the client, we can listen for an event on the signal: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(points) print(&quot;Points for myself now:&quot;, points) end)  "},{"title":"Events (Client-to-Server)​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#events-client-to-server","content":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = { PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), -- Create the new signal }, }  Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: function PointsService:KnitInit() local rng = Random.new() -- Listen for the client to fire this signal, then give random points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- ...other code for cleaning up player data here end  From the client, we can fire the signal like so: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- Fire the signal: PointsService.GiveMePoints:Fire()  Client Remote Signal See the ClientRemoteSignal documentation for more info on how to use the ClientRemoteSignal object. "},{"title":"Unreliable Events​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#unreliable-events","content":"Knit also supports UnreliableRemoteEvents, which is a special version of RemoteEvent. UnreliableRemoteEvents are, as the name suggests, unreliable. When an event is fired on an UnreliableRemoteEvent, the order and delivery of the event is not guaranteed. The listener of the event may receive the events out of order, or possibly not at all. Having unreliable events is useful in scenarios where the data being sent is not crucial to game state. For example, setting the tilt rotation of each avatar's head: if some packets are dropped, this won't affect actual gameplay. The benefit is that unreliable events take up less network bandwidth. To create an unreliable event, use Knit.CreateUnreliableSignal() within the client table of a service: local MyService = Knit.CreateService { Name = &quot;MyService&quot;, Client = { PlayEffect = Knit.CreateUnreliableSignal(), }, }  Using the unreliable signal is the same as normal ones (see the two sections above on events). "},{"title":"Properties​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#properties","content":"It is often useful to replicate data to all or individual players. Instead of creating methods and signals to communicate this data, RemoteProperties can be used. For example, let's refactor the AddPoints method to set a RemoteProperty of the number of points the player has. The client will then be able to easily read this property: -- Create the RemoteProperty: PointsService.Client.Points = Knit.CreateProperty(0) function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points self.Client.Points:SetFor(player, points) end  On the client, we can now easily read the Points property: -- LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- The 'Observe' method will fire for the current value and any time the value changes: PointsService.Points:Observe(function(points) print(&quot;Current number of points:&quot;, points) end)  Using Observe is the easiest way to track the value of a RemoteProperty on the client. Remote Property See the RemoteProperty andClientRemotePropertydocumentation for more info on how to use the RemoteProperty and ClientRemoteProperty objects.  "},{"title":"Full Example​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#full-example","content":""},{"title":"PointsService​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#pointsservice","content":"At the end of this tutorial, we should have a PointsService that looks something like this: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local Signal = require(Knit.Util.Signal) local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, -- Define some properties: PointsPerPlayer = {}, PointsChanged = Signal.new(), Client = { -- Expose signals to the client: PointsChanged = Knit.CreateSignal(), GiveMePoints = Knit.CreateSignal(), Points = Knit.CreateProperty(0), }, } -- Client exposed GetPoints method: function PointsService.Client:GetPoints(player) return self.Server:GetPoints(player) end -- Add Points: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) self.Client.PointsChanged:Fire(player, points) end self.Client.Points:SetFor(player, points) end -- Get Points: function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0 end -- Initialize function PointsService:KnitInit() local rng = Random.new() -- Give player random amount of points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- Clean up data when player leaves: game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) self.PointsPerPlayer[player] = nil end) end return PointsService  "},{"title":"Client Consumer​","type":1,"pageTitle":"Services","url":"/Knit/docs/services#client-consumer","content":"Example of client-side LocalScript consuming the PointsService: -- From a LocalScript local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn):await() local PointsService = Knit.GetService(&quot;PointsService&quot;) local function PointsChanged(points) print(&quot;My points:&quot;, points) end -- Get points and listen for changes: PointsService:GetPoints():andThen(PointsChanged) PointsService.PointsChanged:Connect(PointsChanged) -- Ask server to give points randomly: PointsService.GiveMePoints:Fire()  "}]